package study.chapter08.treedemo;

import java.util.Arrays;

/**
 * @author Randal1
 * @version V1.0
 * @Package study.chapter08.treedemo
 * @data 2020/5/1 12:39
 */
public class TreeDemo {
    public static void main(String[] args) {
        /*
        *
        * 二叉树的查找方式  前序遍历（根--左--右） 中序遍历（左--根--右） 后序遍历（左--右--根）
        *
        *
        * 红黑树特点
        * 1 每个节点颜色属性或黑或红
        * 2 根节点必须为黑色
        * 3 每个叶子节点是黑色
        *       java中的红黑树将使用null表示空节点，因此遍历红黑树时将看不到黑色的叶子节点，只会有红色的叶子节点
        *
        * 4 如果一个节点的颜色为红色，则它的子节点必为黑色
        *       根到节点的路径上不会有两个连续的红色节点，但可以有连续的黑色节点，
        *       若给定黑色节点的个数为 N ,最短路径情况是连续的 N 个黑色，树的高度为 N-1 ,
        *                               最长路径情况为节点红黑相间，树的高度为 2（N-1）,
        *
        * 5 从一个节点到该节点的所有子孙节点的所有路径包含相同数目的黑节点数目
        *
        *
        *
        *
        * 数据插入处理  （进行插入的节点用首先红色描述）
        * 1第一次插入 ，即插入的为根节点 ，此时只需要将根节点涂黑即可
        * 2如果插入节点的父节点是黑色的，此时不违反规则，不用进行操作。
        * 否则以下三种情况要进行操作（变色与旋转）：
        *           2.1  如果插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）都是红色的的
        *                       此时操作之一： 将父节点与叔叔节点涂黑，将祖父节点涂红
        *           2.2  如果插入节点的父节点是红色的，叔叔节点是黑色的，且插入节点是其父节点的左子结点
        *                       此时父节点与祖父节点颜色互换，再以父节点为中心右旋
        *           2.3  如果插入节点的父节点是红色的，叔叔节点是黑色的，且插入节点是其父节点的右子结点
        *                       首先 以父节点为中心左旋  而后重复2.2
        *
        *
        * 数据删除处理
        * 1  数据删除后，如果当前节点是黑色的根节点，不用操作
        * 2  如果当前节点是红色的，说明刚刚移走的后继节点是黑色的，此时，只需要将当前节点涂黑就可以了
        * 3  如果当前节点是黑色的；
        *           3.1 且兄弟节点是红色的，此时父节点与兄弟节点的子节点肯定是黑色的；
        *                           此时将当前节点父节点涂红，将兄弟节点涂黑，然后以当前节点的父节点为中心进行左旋
        *           3.2 且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色；
        *                           此时将当前节点的兄弟节点涂红，将当前节点指向其父节点，将当前节点父节点指向其祖父节点，不旋转。
        *           3.3 且兄弟节点是黑色的，且兄弟节点的左子节点为红色，右子节点为黑色；
        *                           此时将当前节点的兄弟节点涂红，将兄弟节点的左子结点涂黑，然后以兄弟节点为中心进行右旋
        *           3.4 且兄弟节点是黑色的，且兄弟节点的左子节点为黑色（或红色），右子节点为红色；
        *                           此时将当前节点的兄弟节点涂成与父节点相同的颜色，再把父节点涂黑，把兄弟节点的右子节点涂黑，然后以当前节点的父节点为中心进行左旋。
        *
        *
        *
        * */
        BinaryTree<Person> tree=new BinaryTree<>();
        Person per=new Person("A",10);
        tree.add(per);
        tree.add(new Person("B",30));
        tree.add(new Person("C",20));
        tree.add(new Person("D",40));
        tree.add(new Person("F",5));
        System.out.println(Arrays.toString(tree.toArray()));
        /*System.out.println(tree.contains(per));*/

    }
}
